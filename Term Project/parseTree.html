<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gojs/1.8.17/go.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <title>CFG Parse Tree Visualization</title>

</head>

<body>
  <h2 id="title"><b>Context Free Grammar Parse Tree Visualization</b></h2>
  <hr>
  <br> context-free grammar (CFG) is a set of recursive rewriting rules (or productions) used to generate patterns of strings.</br>

<br> A CFG consists of the following components:</br>

<br> > a set of terminal symbols, which are the characters of the alphabet that appear in the strings generated by the grammar.</br>
<br> > a set of nonterminal symbols, which are placeholders for patterns of terminal symbols that can be generated by the nonterminal symbols.</br>
<br> > a set of productions, which are rules for replacing (or rewriting) nonterminal symbols (on the left side of the production) in a string with other nonterminal or terminal symbols (on the right side of the production).</br>
<br> > a start symbol, which is a special nonterminal symbol that appears in the initial string generated by the grammar.</br>
<br> > To generate a string of terminal symbols from a CFG, we:</br>

<br>Begin with a string consisting of the start symbol;</br>
<br>Apply one of the productions with the start symbol on the left hand size, replacing the start symbol with the right hand side of the production;</br>
<br>Repeat the process of selecting nonterminal symbols in the string, and replacing them with the right hand side of some corresponding production, until all nonterminals have been replaced by terminal symbols.</br>
  <hr>

  w =<input id=input type=text value="100p001" onchange="generate(input.value)">
  <pre id=out style="font-weight: bold; color: red"></pre>
  <p></p>
  <em><b>Sample Grammar =</b> S â†’ 0S0 | 1S1 | p</em>
  <hr>
  <h4><em>Parse Tree</em></h4>
  <p></p>

  <script>
    function init(s) {
      var $ = go.GraphObject.make;  // for conciseness in defining templates
      myDiagram =
        $(go.Diagram, "myDiagramDiv",
          {
            allowCopy: false,
            allowDelete: false,
            allowMove: false,
            initialAutoScale: go.Diagram.Uniform,
            initialContentAlignment: go.Spot.Center,
            layout:
              $(FlatTreeLayout,  // custom Layout, defined below
                {
                  angle: 90,
                  compaction: go.TreeLayout.CompactionNone
                }),
            "undoManager.isEnabled": true
          });
      myDiagram.nodeTemplate =
        $(go.Node, "Vertical",
          { selectionObjectName: "BODY" },
          $(go.Panel, "Auto", { name: "BODY" },
            $(go.Shape, "RoundedRectangle",
              new go.Binding("fill"),
              new go.Binding("stroke")),
            $(go.TextBlock,
              { font: "bold 12pt Arial, sans-serif", margin: new go.Margin(4, 2, 2, 2) },
              new go.Binding("text"))
          ),
          $(go.Panel,  // this is underneath the "BODY"
            { height: 17 },  // always this height, even if the TreeExpanderButton is not visible
            $("TreeExpanderButton")
          )
        );
      myDiagram.linkTemplate =
        $(go.Link,
          $(go.Shape, { strokeWidth: 1.5 }));
      // set up the nodeDataArray, describing each part of the sentence
      var nodeDataArray = [{ key: 1, text: 'S', fill: "#f68c06", stroke: "#4d90fe" }]
      let count = 1, parentCount = 1, nextParentCount = 1
      s.forEach(element => {
        parentCount = nextParentCount
        element.split('').forEach(word => {
          count++
          if (word == 'S') {
            nodeDataArray.push({ key: count, text: word, fill: "#f68c06", stroke: "#4d90fe", parent: parentCount })
            nextParentCount = count
          } else {
            nodeDataArray.push({ key: count, text: word, fill: "#f68c06", stroke: "#4d90fe", parent: parentCount })
          }

        });
      });
      // create the Model with data for the tree, and assign to the Diagram
      myDiagram.model =
        $(go.TreeModel,
          { nodeDataArray: nodeDataArray });
    }
    // Customize the TreeLayout to position all of the leaf nodes at the same vertical Y position.
    function FlatTreeLayout() {
      go.TreeLayout.call(this);  // call base constructor
    }
    go.Diagram.inherit(FlatTreeLayout, go.TreeLayout);
    // This assumes the TreeLayout.angle is 90 -- growing downward
    FlatTreeLayout.prototype.commitLayout = function () {
      go.TreeLayout.prototype.commitLayout.call(this);  // call base method first
      // find maximum Y position of all Nodes
      var y = -Infinity;
      this.network.vertexes.each(function (v) {
        y = Math.max(y, v.node.position.y);
      });
      // move down all leaf nodes to that Y position, but keeping their X position
      this.network.vertexes.each(function (v) {
        if (v.destinationEdges.count === 0) {
          // shift the node down to Y
          v.node.position = new go.Point(v.node.position.x, y);
          // extend the last segment vertically
          v.node.toEndSegmentLength = Math.abs(v.centerY - y);
        } else {  // restore to normal value
          v.node.toEndSegmentLength = 10;
        }
      });
    };
    // end FlatTreeLayout

    "use strict";
    function delta(c, p) { // Unary addition
      if (c == '0' && p == 'S') return "0S0";
      if (c == '1' && p == 'S') return "1S1";
      if (c == 'p') return "p";
      return '';  //default -- no transition
    }
    function generate(w, initState = 'S') {
      w.split('').forEach(element => {
        if (element != '0' & element != '1' & element != 'p') {
          out.innerHTML = 'Wrong Input\nPlease use "0,1,p"'
          return
        }
      });
      //w: input String
      //init: start symbol
      //g: generated String
      let steps = []
      let g = initState
      for (let i = 0; i < w.length; i++) {
        let c = w[i], p = g[i]
        if (c == p) continue
        let d = delta(c, p)
        if (d == '') {
          input.selectionStart = i
          input.selectionEnd = i + 1
          break
        }
        g = g.replace(p, d)
        steps.push(d)
        out.innerHTML = (w==g ? "Accept" : "Reject")
      }
      init(steps)
    }
  </script>
</body>

<body onload="generate(input.value)">
  <div id="sample">
    <div id="myDiagramDiv"
      style="border: 1px solid black; width: 100%; height: 500px; position: relative; -webkit-tap-highlight-color: rgba(255, 255, 255, 0); cursor: auto;">
      <canvas id="myCanvas" tabindex="0" width="857" height="622"
        style="position: absolute; top: 0px; left: 0px; z-index: 2; user-select: none; width: 686px; height: 498px; cursor: auto;">This
        text is displayed if your browser does not support the Canvas HTML element.</canvas>
      <div style="position: absolute; overflow: auto; width: 686px; height: 498px; z-index: 1;">
        <div style="position: absolute; width: 1px; height: 1px;"></div>
      </div>
    </div>
    <p>A <em>parse tree</em> is an ordered, rooted tree representing the structure of a sentence, broken down to
      parts-of-speech.</p>
  </div>
</body>

</html>